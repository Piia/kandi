% !TEX root = kandi.tex

\section{Regressiotestaaminen jatkuvassa integraatiossa}

Jatkuvan integraation myötä samaa ohjelmakoodia muokkaavat kymmenet, sadat tai jopa tuhannet ohjelmistokehittäjät ja heidän kaikkien tulee kommitoida tekemänsä muutokset vähintään kerran päivässä \cite{MSB17}. Jokainen kommit johtaa ohjelmiston kokoamiseen ja testaamiseen jatkuvan integraation palvelimella, jolloin regressiotestaaminen muodostaa helposti jatkuvaan integraatioon pullonkaulan \cite{ERP14}. 

Regressiotestaamista käytetään jatkuvan integraation palvelimella ohjelmiston toimivuuden ja oikeellisuuden tarkistamiseen jokaisen muutoksen jälkeen \cite{ERP14}. Toimivuus ja oikeellisuus vaarantuvat alati kommitoiduissa muutoksissa, minkä vuoksi regressiotestaaminen on tärkeä osa jatkuvaa integraatiota. Paras tapa ehkäistä virheiden kasaantumista ja isoja rakenteellisia ongelmia onkin toteuttaa riskialttiit muutokset ja korjata virheet samantien \cite{HTH+16}. Regressiotestaamista ei käytetä kaikkialla suurten kustannusten vuoksi \cite{LIH17}.

%Jatkuvan integraation palvelimen on tarkoitus tuottaa puolueeton ja luotettava testitulos, joka vertautuu ohjelmiston käyttämiseen oikeissa tuotanto-olosuhteissa. \cite{Fow06} 
%Jatkuvan integraation luonteen vuoksi ohjelmisto regressiotestataan vähintään yhtä monta kertaa kuin ohjelmistolla on kehittäjiä. ERP

Ohjelmistokehittäjien kokema tyytyväisyys jatkuvaa integraatiota kohtaan on osaltaan riippuvainen testitoimintojen toimivuudesta ja sujuvuudesta \cite{MSB17}. Ihjelmistokehitystiimi ei kerta kaikkiaan voi työskennellä luotettavasti rikkinäisen ohjelmiston parissa. Jatkuvan integraation palvelimen antama palaute onnistuneesta testaamisesta toimii vakuutena koko ohjelmistokehitystiimille, että työtä voi jatkaa rauhassa ja se rakentuu toimivan kokonaisuuden päälle. Mikäli testejä epäonnistuu, ohjelmointivirheet on mahdollista jäljittää kommitin ja testin tarkkuudella. Virheet korjataan, eikä periaatteessa kenenkään työtä sotketa. Ohjelmiston julkaisun lähestyessä regressiotestaaminen muuttuu aina vain tärkeämmäksi, koska jatkuvan integraation palvelimen on tarkoitus olla neutraali testiympäristö ja tuotannossa ilmenevät virheet karkoittavat asiakkaita \cite{ERP14}. 

Regressiotestaamista varten muodostetaan oma testikokonaisuus, sillä testipohjan koko on miltei aina liian suuri suoritettavaksi joka integraatiolla. Yleisimmät tavat muodostaa testikokonaisuus ovat rajaaminen ja priorisointi. Testikokonaisuuden rajaamisessa kokonaisuus muodostetaan testeistä, jotka tuottavat eniten kulloinkin hyödyllistä tietoa. Koodipohjasta voidaan esimerkiksi tehdä jokaisella kommitilla riippuvuusanalyysi, joka paljastaa, mihin uusi muutos vaikuttaa. Kokonaisuuden rajaamista helpottaa ohjelmiston modulaarinen, eli osista muodostuva rakenne, jossa osat kootaan itsenäisesti. Näin testaamista voidaan myös suorittaa rinnakkain. Testikokonaisuuden priorisoimisella pyritään nopeuttamaan regressiotestaamisen palautteen saamiseen kuluvaa aikaa. Palaute on tärkeä osa jatkuvaa integraatiota. Mikäli jatkuvan integraation palvelin on suuren kuormituksen alaisena, palvelin voi jättää alemman priorisaation testejä ajamatta ajoon jonottavien testien määrän vuoksi. \cite{ERP14}


\subsection{Kustannukset}

Jatkuvan integraation käyttö on kustannustehokkaampaa kuin integraatio erillisenä tuotantovaiheena \cite{SB13}. Tämä johtuu pitkälti ohjelmistotuotantoprosessin läpinäkyvyyden kasvusta, kun ohjelmistoon syntyneet virheet saatetaan koko ohjelmistokehitystiimin tietoon. Pieniä virheitä on suuria virheitä nopeampi korjata, mikä vähentää kuluvia työtunteja ja ehkäisee aikataulun venymistä. Näin ehkäistään myös rikkonaisen ikkunan syndroomaa, eli ohjelmistokehittäjien taipumusta vältellä suurien virheiden korjaamista. Tuotantoon asti ehtineet virheet ovat erityisen kalliita, sillä uudet käyttäjät eivät pidä virheistä sen enempää kuin vanhat käyttäjätkään \cite{LIH17}. Hyvä esimerkki tästä on Pokemon Go -mobiilipeli, joka saavutti maailmanlaajuisen suosion, mutta käyttäjät kyllästyivät nopeasti pelin pelaamista häiritseviin virheisiin.

Regressiotestaamisella pyritään nopeuttamaan virheiden löytymistä ja korjaamista, mutta sen käyttämisen kustannukset eivät saa nousta hyötyjä suuremmiksi \cite{LIH17}. Ohjelmistokehittäjien on koettava, että heidän ponnistelunsa testien kirjoittamisen ja testipohjan ylläpitämisen parissa on tarpeellista. Regressiotestaamisen kustannuksiin vaikuttavat erityisesti valtavat koodi- ja testipohjat. Niissä on paljon riippuvuuksia ja moduuleita, jotka voivat olla tahoillaan kehitettävinä. Tästä aiheutuu tarpeettomia epäonnistumisia ohjelmiston koonnissa ja testaamisessa. Ongelmat vähenevät, kun ohjelmistokehittäjät testaavat koodia riittävästi ennen kommitointia \cite{ERP14}. Toisaalta kuten luvussa 2.2 mainittiin, ennen kommitointia tapahtuvasta testaamisesta ei saa muodostua ohjelmistokehitykseen toista pullonkaulaa. Ohjelmistokehittäjät eivät välttämättä uskalla kommitoida koodia ilman liiallista testaamista, josta aiheutuu sekä ylimääräisiä työtunteja että palvelinresurssien kulumista. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{koodipohja.pdf}
    \caption{Testipohjan osuus koodipohjasta kasvaa ajan myötä \cite{LIH17}.}
    \label{koodipohja}
\end{figure}

Luvun alussa todettiin, että suurilla määrillä kommitteja regressiotestaaminen muodostaa helposti pullonkaulan jatkuvaan integraatioon. Koodipohjan, testipohjan ja kommitoinnin kasvun mukana hupenevat myös käytössä olevat resurssit \cite{ERP14}. Regressiotestaaminen kuluttaa yhtä paljon työaikaa kuin varsinainen ohjelmiston kehittäminen, sillä regressiotestien tekeminen ja testipohjan ylläpitäminen vie aikaa \cite{MGN+17}. Se on paljon, sillä regressiotestaaminen on vain yksi osa ohjelmiston testaamista. Eräässä tutkimuksessa (katso kuva \ref{koodipohja}) mitattiin kolmen ja puolen vuoden aikana javaprojektien koodi- ja testipohjien kasvua \cite{LIH17}. Jakson aikana testipohjien koko on kaksinkertaistunut, kun samalla koodipohjat ovat kasvaneet vain puolella. Suuri koodipohja vaikeuttaa testikokoelman muodostamista, sillä perinteiset menetelmät testikokoelman muodostamiseen perustuvat koodipohjan analysoimiseen ja sen kasvu tekee tästä liian raskasta.
%Ohjelmiston kokoaminen ja regressiotestaaminen voi johtaa palvelinresurssien riittämättömyyteen.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{buildfail.pdf}
    \caption{Koontiversion epäonnistumiseen johtaneet syyt \cite{LIH17}.}
    \label{buildfail}
\end{figure}

Myös testeissä itsessään voi olla virheitä, joiden tunnistaminen ja korjaaminen on vaikeaa \cite{LIH17}. Näin on erityisesti silloin, jos testitoiminnot on rakennettu osin ulkopuolisen palveluntarjoajan palveluiden varaan ja testejä voi joutua muuttamaan jokaisen palveluntarjoajan tekemän muutoksen myötä \cite{HTH+16}. Regressiotestaamisen kustannukset on otettava tarkasti huomioon laskettaessa jatkuvan integraation kustannuksia. Jatkuvan integraation palvelimella koontiversioista 82\% onnistuu, jolloin vastaavasti 12\% epäonnistuu. Epäonnistuneista koontiversioista (katso kuva \ref{buildfail}) 35\% on turhia ja resursseja hukkaavia tapahtumia. Koontiversio joko kaatuu, testit ovat epädeterministisiä tai niissä on virhe. Näin ollen kaikista jatkuvan integraation palvelimen koonneista noin 4\% olisi voitu välttää kokonaan. Lisäksi nämä turhaksi luokitellut epäonnistumiset johtavat useisiin peräkkäisiin epäonnistuneisiin koonteihin, kun virhettä yritetään korjata.

Testikokonaisuuden valinta suuntaa regressiotestaamisen kustannustehokkuutta \cite{LIH17}. Sopivaa testikokonaisuutta ja sen muodostamismenetelmää kannattaa tutkia projektikohtaisesti. Myös jatkuvan integraation palvelimen tuottama tilastotieto koontiversioiden onnistumisesta auttaa sopivan tavan löytämisessä. Testikokonaisuuden rajaaminen ja testikokonaisuuden priorisointi ovat käytetyimmät menetelmät \cite{ERP14}. Ne eivät kuitenkaan sovi sellaisenaan jatkuvan integraation kehyksessä, sillä niiden käyttö perustuu pitkälti koodipohjan analysointiin. Testikokonaisuuksien kustannustehokkuutta voi sen sijaan kasvattaa strategialla, joka yhdistelee eri menetelmiä. Esimerkiksi Googlella isoin parannus saatiin aikaan, kun ennen kommitointia suoritettavassa testaamisessa rajataan testikokonaisuuksia käyttämällä hyväksi tietoa aiemmista testituloksista. Kommitoinnin jälkeen sen sijaan priorisointi nopeutti merkittävästi ohjelmistokehittäjiä hyöddyttävän palautteen saantiaikaa. 




\clearpage