% !TEX root = kandi.tex

\section{Regressiotestaaminen jatkuvassa integraatiossa}

Jatkuvan integraation myötä samaa ohjelmakoodia muokkaavat kymmenet, sadat tai jopa tuhannet ohjelmistokehittäjät ja heidän kaikkien tulee kommitoida tekemänsä muutokset vähintään kerran päivässä \cite{MSB17}. Jokainen kommit johtaa ohjelmiston kokoamiseen ja testaamiseen jatkuvan integraation palvelimella, jolloin regressiotestaaminen muodostaa helposti jatkuvaan integraatioon pullonkaulan \cite{ERP14}. Regressiotestaamista käytetään jatkuvan integraation palvelimella koko ohjelmiston toimivuuden ja oikeellisuuden testaamiseen muutoksien jälkeen. Ohjelmiston ollessa alati muutoksien kohteena sen toimivuus ja oikeellisuus vaarantuvat joka muutoksessa, minkä vuoksi regressiotestaaminen on tärkeä osa jatkuvaa integraatiota. Paras tapa ehkäistä virheiden kasaantumista ja isoja rakenteellisia ongelmia on toteuttaa muutokset ja korjata virheet mahdollisimman tiuhaan \cite{HTH+16}. Regressiotestaaminen on yleistä, mutta sitä ei käytetä kaikkialla suurten kustannusten vuoksi\cite{LIH17}.

%Jatkuvan integraation palvelimen on tarkoitus tuottaa puolueeton ja luotettava testitulos, joka vertautuu ohjelmiston käyttämiseen oikeissa tuotanto-olosuhteissa. \cite{Fow06} 
%Jatkuvan integraation luonteen vuoksi ohjelmisto regressiotestataan vähintään yhtä monta kertaa kuin ohjelmistolla on kehittäjiä. ERP

Ohjelmistokehittäjien kokema tyytyväisyys jatkuvaa integraatiota kohtaan on osaltaan riippuvainen testitoimintojen toimivuudesta ja sujuvuudesta \cite{MSB17}. Esimerkiksi ohjelmistokehitystiimi ei voi työskennellä luotettavasti rikkinäisen ohjelmiston parissa. Jatkuvan integraation palvelimen antama palaute onnistuneesta testaamisesta toimii vakuutena koko ohjelmistokehitystiimille, että työtä voi jatkaa rauhassa ja se rakentuu toimivan kokonaisuuden päälle. Mikäli testejä epäonnistuu, ohjelmointivirheet on mahdollista jäljittää kommitin ja testin tarkkuudella. Virheet korjataan, eikä periaatteessa kenenkään työtä sotketa. Ohjelmiston julkaisun lähestyessä regressiotestaaminen muuttuu aina vain tärkeämmäksi, koska jatkuvan integraation palvelimen on tarkoitus olla neutraali testiympäristö ja tuotannossa ilmenevät virheet karkoittavat asiakkaita \cite{ERP14}. 

Regressiotestaamista varten muodostetaan oma testikokonaisuus, sillä testipohjan koko on miltei aina liian suuri suoritettavaksi joka integraatiolla. Yleisimmät tavat muodostaa testikokonaisuus on rajaaminen ja priorisointi. Testikokonaisuuden rajaamisessa kokonaisuus muodostetaan testeistä, jotka tuottavat eniten kulloinkin hyödyllistä tietoa. Koodipohjasta voidaan esimerkiksi tehdä jokaisella kommitilla riippuvuusanalyysi, joka paljastaa, mihin uusi muutos vaikuttaa. Kokonaisuuden rajaamista helpottaa ohjelmiston modulaarinen, eli osista muodostuva rakenne, jossa osat kootaan itsenäisesti. Näin testaamista voidaan myös suorittaa rinnakkain. Testikokonaisuuden priorisoimisella pyritään nopeuttamaan regressiotestaamisen palautteen saamiseen kuluvaa aikaa. Palaute on tärkeä osa jatkuvaa integraatiota \cite{ERP14}.


\subsection{Kustannukset}

Jatkuvan integraation käyttö on kustannustehokkaampaa kuin integraatio erillisenä tuotantovaiheena. Tämä johtuu pitkälti ohjelmistotuotantoprosessin läpinäkyvyyden kasvusta, kun ohjelmistoon syntyneet virheet saatetaan koko ohjelmistokehitystiimin tietoon. Pieniä virheitä on suuria virheitä nopeampi korjata, mikä vähentää kuluvia työtunteja ja ehkäisee aikataulun venymistä. Näin ehkäistään myös rikkonaisen ikkunan syndroomaa, eli ohjelmistokehittäjien taipumusta vältellä suurien virheiden korjaamista \cite{SB13}. Tuotantoon asti ehtineet virheet ovat erityisen kalliita, sillä uudet käyttäjät eivät pidä virheistä sen enempää kuin vanhat käyttäjätkään \cite{LIH17}. Hyvä esimerkki tästä on Pokemon Go -mobiilipeli, joka saavutti maailmanlaajuisen suosion, mutta käyttäjät kyllästyivät nopeasti pelaamista häiritseviin virheisiin.

Regressiotestaamisella pyritään nopeuttamaan virheiden löytymistä ja korjaamista, mutta sen käyttämisen kustannukset eivät saa nousta hyötyjä suuremmiksi. Ohjelmistokehittäjien on koettava, että heidän ponnistelunsa testien kirjoittamisen ja testipohjan ylläpitämisen parissa on tarpeellista \cite{LIH17}. Regressiotestaamisen kustannuksiin vaikuttavat erityisesti valtavat koodi- ja testipohjat. Niissä on paljon riippuvuuksia ja moduuleita, jotka voivat olla tahoillaan kehitettävinä. Tästä aiheutuu tarpeettomia epäonnistumisia testaamisessa. Ongelmat vähenevät, kun ohjelmistokehittäjät testaavat koodia riittävästi ennen kommitointia. Toisaalta kuten luvussa 2.2 mainittiin, ennen kommitointia tapahtuvasta testaamisesta ei saa muodostua ohjelmistokehitykseen toista pullonkaulaa. Ohjelmistokehittäjä eivät välttämättä uskalla kommitoida koodia ilman liiallista testaamista, josta aiheutuu sekä ylimääräisiä työtunteja että palvelinresurssien kulumista \cite{ERP14}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{koodipohja.pdf}
    \caption{Testipohjan osuus koodipohjasta kasvaa ajan myötä \cite{LIH17}.}
    \label{koodipohja}
\end{figure}

Luvun alussa todettiin, että suurilla määrillä kommitteja regressiotestaaminen muodostaa helposti pullonkaulan jatkuvaan integraatioon. Koodipohjan, testipohjan ja kommitoinnin kasvun mukana hupenevat myös käytössä olevat resurssit \cite{ERP14}. Regressiotestaaminen kuluttaa yhtä paljon työaikaa kuin varsinainen ohjelmiston kehittäminen, sillä regressiotestien tekeminen ja testipohjan ylläpitäminen vie aikaa. Se on paljon, sillä regressiotestaaminen on vain yksi osa ohjelmiston testaamista \cite{MGN+17}. Eräässä tutkimuksessa (katso kuva \ref{koodipohja}) mitattiin kolmen ja puolen vuoden aikana javaprojektien koodi- ja testipohjan kasvua \cite{LIH17}. Jakson aikana testipohjan koko on kaksinkertaistunut, samalla kun koodipohja on kasvanut vain puolella. Suuri koodipohja vaikeuttaa testikokoelman muodostamista, sillä perinteiset menetelmät siihen perustuvat koodipohjan analysoimiseen ja koodipohjan kasvu tekee siitä liian raskasta.
%Ohjelmiston kokoaminen ja regressiotestaaminen voi johtaa palvelinresurssien riittämättömyyteen.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{buildfail.pdf}
    \caption{Koontiversion epäonnistumiseen johtaneet syyt \cite{LIH17}.}
    \label{buildfail}
\end{figure}

Myös testeissä itsessään voi olla virheitä, joiden tunnistaminen ja korjaaminen on vaikeaa \cite{LIH17}. Näin on erityisesti silloin, jos testitoiminnot on rakennettu osin ulkopuolisen palveluntarjoajan palveluiden varaan ja testejä voi joutua muuttamaan jokaisen palveluntarjoajan muutoksien myötä \cite{HTH+16}. Regressiotestaamisen kustannukset on otettava tarkasti huomioon laskettaessa jatkuvan integraation kustannuksia. Jatkuvan integraation palvelimella koontiversioista 82\% onnistuu, jolloin vastaavasti 12\% epäonnistuu. Epäonnistuneista koontiversioista (katso kuva \ref{buildfail}) 35\% on turhia ja resursseja hukkaavia tapahtumia. Koontiversio joko kaatuu, testit ovat epädeterministisiä tai niissä on virhe. Näin ollen kaikista jatkuvan integraation palvelimen koonneista noin 4\% olisi voitu välttää kokonaan. Lisäksi nämä turhaksi luokitellut epäonnistumiset johtavat useisiin peräkkäisiin epäonnistuneisiin koonteihin, kun virhettä yritetään korjata.

Testikokonaisuuden valinta suuntaa regressiotestaamisen kustannustehokkuutta. Sopivaa testikokonaisuutta ja sen muodostamismenetelmää kannattaa tutkia projektikohtaisesti. Myös jatkuvan integraation palvelimen tilastot ovat tärkeä osa sopivan tavan löytämisessä \cite{LIH17}. Testikokonaisuuden rajaaminen ja testikokonaisuuden priorisointi ovat käytetyimmät muodostamismenetelmät. Ne eivät kuitenkaan sovi sellaisenaan jatkuvan integraation kehyksessä, sillä niiden käyttö perustuu pitkälti koodin analysointityökaluihin, joiden soveltaminen suureen koodi- ja testipohjaan on raskasta. Testikokonaisuuksien kustannustehokkuutta voi sen sijaan kasvattaa strategialla, joka yhdistelee eri menetelmiä. Esimerkiksi Googlella isoin parannus saatiin aikaan, kun ennen kommitointia suoritettavassa testaamisessa rajataan testikokonaisuuksia tietoa aiemmista testituloksista. Kommitoinnin jälkeen sen sijaan priorisointi parantaa merkittävästi hyödyllisen palautteen saamisaikaa \cite{ERP14}. 




\clearpage